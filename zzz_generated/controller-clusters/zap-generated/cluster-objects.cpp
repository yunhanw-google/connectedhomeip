/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include "cluster-objects.h"

#pragma GCC diagnostic ignored "-Wstack-usage="

namespace chip {
namespace app {
namespace clusters {
namespace AccountLoginCluster {
}

namespace ApplicationLauncherCluster {
}

namespace ContentLauncherCluster {
}

namespace DoorLockCluster {
}

namespace GeneralCommissioningCluster {
}

namespace GroupsCluster {
}

namespace IdentifyCluster {
}

namespace KeypadInputCluster {
}

namespace MediaPlaybackCluster {
}

namespace NetworkCommissioningCluster {
}

namespace OtaSoftwareUpdateProviderCluster {
}

namespace OperationalCredentialsCluster {
}

namespace ScenesCluster {
}

namespace TvChannelCluster {
}

namespace TargetNavigatorCluster {
}

namespace TestClusterCluster {
namespace SimpleStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kaFieldId, a)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kbFieldId, b)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kcFieldId, c)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kdFieldId, d)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(keFieldId, e)));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kaFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, a));
            break;
        case kbFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, b));
            break;
        case kcFieldId:
            uint8_t v;
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, v));
            // zap issue 231 to return right enum type
            c = static_cast<uint8_t>(v);
            break;
        case kdFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, d));
            break;
        case keFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, e));
            break;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace SimpleStruct
namespace NestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kaFieldId, a)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kbFieldId, b)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kdFieldId, d)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(keFieldId, e)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kfFieldId, f)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kgFieldId, g)));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kaFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, a));
            break;
        case kbFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, b));
            break;
        case kdFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case keFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kfFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kgFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kaFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, a));
            break;
        case kbFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, b));
            break;
        case kdFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, d));
            break;
        case keFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, e));
            break;
        case kfFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, f));
            break;
        case kgFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, g));
            break;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NestedStructList
namespace DoubleNestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kaFieldId, a)));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kaFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kaFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, a));
            break;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace DoubleNestedStructList
namespace NestedStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kaFieldId, a)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kbFieldId, b)));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kaFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, a));
            break;
        case kbFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, b));
            break;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NestedStruct
namespace TestListStructOctet {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag)
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(kfabricIndexFieldId, fabricIndex)));
    ReturnErrorOnFailure(ClusterObjectUtils::Encode(writer, TLV::ContextTag(koperationalCertFieldId, operationalCert)));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        uint64_t tag = reader.GetTag();
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kfabricIndexFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, fabricIndex));
            break;
        case koperationalCertFieldId:
            ReturnErrorOnFailure(ClusterObjectUtils::Decode(reader, operationalCert));
            break;
        default:
            ReturnLogErrorOnFailure(CHIP_ERROR_INVALID_TLV_TAG);
        }
    }
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TestListStructOctet
} // namespace TestClusterCluster

} // namespace clusters
} // namespace app
} // namespace chip
