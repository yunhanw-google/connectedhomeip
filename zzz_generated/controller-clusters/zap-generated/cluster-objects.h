/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/util/basic-types.h>

namespace chip {
namespace app {
namespace clusters {

namespace AccountLoginCluster {
constexpr ClusterId kClusterId = 0x050E;

}
namespace ApplicationLauncherCluster {
constexpr ClusterId kClusterId = 0x050C;

}
namespace ContentLauncherCluster {
constexpr ClusterId kClusterId = 0x050A;

}
namespace DoorLockCluster {
constexpr ClusterId kClusterId = 0x0101;

}
namespace GeneralCommissioningCluster {
constexpr ClusterId kClusterId = 0x0030;

}
namespace GroupsCluster {
constexpr ClusterId kClusterId = 0x0004;

}
namespace IdentifyCluster {
constexpr ClusterId kClusterId = 0x0003;

}
namespace KeypadInputCluster {
constexpr ClusterId kClusterId = 0x0509;

}
namespace MediaPlaybackCluster {
constexpr ClusterId kClusterId = 0x0506;

}
namespace NetworkCommissioningCluster {
constexpr ClusterId kClusterId = 0x0031;

}
namespace OtaSoftwareUpdateProviderCluster {
constexpr ClusterId kClusterId = 0x0029;

}
namespace OperationalCredentialsCluster {
constexpr ClusterId kClusterId = 0x003E;

}
namespace ScenesCluster {
constexpr ClusterId kClusterId = 0x0005;

}
namespace TvChannelCluster {
constexpr ClusterId kClusterId = 0x0504;

}
namespace TargetNavigatorCluster {
constexpr ClusterId kClusterId = 0x0505;

}
namespace TestClusterCluster {
constexpr ClusterId kClusterId = 0x050F;

// Enum for SimpleEnum
enum class SimpleEnum : uint8_t
{
    SIMPLE_ENUM_UNSPECIFIED = 0,
    SIMPLE_ENUM_VALUE_A     = 1,
    SIMPLE_ENUM_VALUE_B     = 2,
    SIMPLE_ENUM_VALUE_C     = 3,
};

namespace SimpleStruct {
enum FieldId
{
    kaFieldId = 0; kbFieldId = 1; kcFieldId = 2; kdFieldId = 3; keFieldId = 4;
};
struct Type
{
    uint8_t a;
    bool b;
    ENUM8 c;
    chip::ByteSpan d;
    Span<const char> e;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}
namespace NestedStructList {
enum FieldId
{
    kaFieldId = 0; kbFieldId = 1; kdFieldId = 2; keFieldId = 3; kfFieldId = 4; kgFieldId = 5;
};
struct Type
{
    uint8_t a;
    bool b;
    DataModel::List<SimpleStruct::Type> d;
    DataModel::List<uint32_t> e;
    DataModel::List<chip::ByteSpan> f;
    DataModel::List<uint8_t> g;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}
namespace DoubleNestedStructList {
enum FieldId
{
    kaFieldId = 0;
};
struct Type
{
    DataModel::List<NestedStructList::Type> a;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}
namespace NestedStruct {
enum FieldId
{
    kaFieldId = 0; kbFieldId = 1;
};
struct Type
{
    uint8_t a;
    bool b;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}
namespace TestListStructOctet {
enum FieldId
{
    kfabricIndexFieldId = 0; koperationalCertFieldId = 1;
};
struct Type
{
    uint64_t fabricIndex;
    chip::ByteSpan operationalCert;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}
}
}
} // namespace clusters
} // namespace app
} // namespace chip
